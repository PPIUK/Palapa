{"version":3,"sources":["getCollapsedMarginTop.ts"],"names":["getCollapsedMarginTop","precedent","current","topMostMarginBottom","styles","nativeBlockRet","marginBottom","bottomMostMarginTop","marginTop","Math","min"],"mappings":";;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASA,qBAAT,CACbC,SADa,EAEbC,OAFa,EAGE;AACf,QAAMC,mBAAmB,GACvB,OAAOF,SAAS,CAACG,MAAV,CAAiBC,cAAjB,CAAgCC,YAAvC,KAAwD,QAAxD,GACIL,SAAS,CAACG,MAAV,CAAiBC,cAAjB,CAAgCC,YADpC,GAEI,IAHN;AAIA,QAAMC,mBAAmB,GACvB,OAAOL,OAAO,CAACE,MAAR,CAAeC,cAAf,CAA8BG,SAArC,KAAmD,QAAnD,GACIN,OAAO,CAACE,MAAR,CAAeC,cAAf,CAA8BG,SADlC,GAEI,IAHN;;AAIA,MAAIL,mBAAmB,IAAI,IAAvB,IAA+BI,mBAAmB,IAAI,IAA1D,EAAgE;AAC9D,WAAO,IAAP;AACD;;AACD,MAAIJ,mBAAmB,GAAG,CAAtB,IAA2BI,mBAAmB,GAAG,CAArD,EAAwD;AACtD,WACEE,IAAI,CAACC,GAAL,CAASP,mBAAT,EAA8BI,mBAA9B,IAAqDJ,mBADvD;AAGD;;AACD,MAAIA,mBAAmB,GAAG,CAAtB,IAA2BI,mBAAmB,GAAG,CAArD,EAAwD;AACtD,WAAOJ,mBAAmB,GAAGI,mBAAtB,GAA4CJ,mBAAnD;AACD;;AACD,MAAIA,mBAAmB,GAAGI,mBAA1B,EAA+C;AAC7C,WAAO,CAAP;AACD;;AACD,SAAOA,mBAAmB,GAAGJ,mBAA7B;AACD","sourcesContent":["import { TNode } from '@native-html/transient-render-engine';\n\n/**\n * Compute a TNode top margin to satisfy requirements expressed in CSS\n * standard regarding margin collapsing.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing\n * for a reference.\n *\n * @param precedent - The node above the one for which we need to compute top margin.\n * @param current - The node for which a margin top might collapse.\n */\nexport default function getCollapsedMarginTop(\n  precedent: TNode,\n  current: TNode\n): null | number {\n  const topMostMarginBottom =\n    typeof precedent.styles.nativeBlockRet.marginBottom === 'number'\n      ? precedent.styles.nativeBlockRet.marginBottom\n      : null;\n  const bottomMostMarginTop =\n    typeof current.styles.nativeBlockRet.marginTop === 'number'\n      ? current.styles.nativeBlockRet.marginTop\n      : null;\n  if (topMostMarginBottom == null || bottomMostMarginTop == null) {\n    return null;\n  }\n  if (topMostMarginBottom < 0 && bottomMostMarginTop < 0) {\n    return (\n      Math.min(topMostMarginBottom, bottomMostMarginTop) - topMostMarginBottom\n    );\n  }\n  if (topMostMarginBottom < 0 || bottomMostMarginTop < 0) {\n    return topMostMarginBottom + bottomMostMarginTop - topMostMarginBottom;\n  }\n  if (topMostMarginBottom > bottomMostMarginTop) {\n    return 0;\n  }\n  return bottomMostMarginTop - topMostMarginBottom;\n}\n"]}