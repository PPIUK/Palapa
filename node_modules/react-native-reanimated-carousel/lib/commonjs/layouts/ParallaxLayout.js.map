{"version":3,"sources":["ParallaxLayout.tsx"],"names":["ParallaxLayout","props","handlerOffsetX","parallaxScrollingOffset","parallaxScrollingScale","parallaxAdjacentItemScale","Math","pow","index","width","height","loop","data","children","visibleRanges","vertical","React","useState","shouldUpdate","setShouldUpdate","size","x","offsetXStyle","value","translate","Extrapolate","EXTEND","zIndex","CLAMP","scale","transform","translateY","translateX","interpolate","updateView","useCallback","negativeRange","positiveRange","runOnJS","position"],"mappings":"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","sourcesContent":["import React from 'react';\nimport Animated, {\n    Extrapolate,\n    interpolate,\n    runOnJS,\n    useAnimatedReaction,\n    useAnimatedStyle,\n} from 'react-native-reanimated';\nimport type { ComputedDirectionTypes } from 'src/types';\nimport { useOffsetX } from '../hooks/useOffsetX';\nimport type { IVisibleRanges } from '../hooks/useVisibleRanges';\nimport { LazyView } from '../LazyView';\nimport type { ILayoutConfig } from './parallax';\n\nexport const ParallaxLayout: React.FC<\n    ComputedDirectionTypes<\n        {\n            loop?: boolean;\n            handlerOffsetX: Animated.SharedValue<number>;\n            index: number;\n            data: unknown[];\n            visibleRanges: IVisibleRanges;\n        } & ILayoutConfig\n    >\n> = (props) => {\n    const {\n        handlerOffsetX,\n        parallaxScrollingOffset = 100,\n        parallaxScrollingScale = 0.8,\n        parallaxAdjacentItemScale = Math.pow(parallaxScrollingScale, 2),\n        index,\n        width,\n        height,\n        loop,\n        data,\n        children,\n        visibleRanges,\n        vertical,\n    } = props;\n\n    const [shouldUpdate, setShouldUpdate] = React.useState(false);\n\n    const size = props.vertical ? props.height : props.width;\n\n    const x = useOffsetX(\n        {\n            handlerOffsetX,\n            index,\n            size,\n            data,\n            loop,\n        },\n        visibleRanges\n    );\n\n    const offsetXStyle = useAnimatedStyle(() => {\n        const value = x.value / size;\n\n        const translate = interpolate(\n            value,\n            [-1, 0, 1],\n            [\n                -size + parallaxScrollingOffset,\n                0,\n                size - parallaxScrollingOffset,\n            ],\n            Extrapolate.EXTEND\n        );\n\n        const zIndex = interpolate(\n            value,\n            [-1, 0, 1],\n            [0, size, 0],\n            Extrapolate.CLAMP\n        );\n\n        const scale = interpolate(\n            value,\n            [-1, 0, 1],\n            [\n                parallaxAdjacentItemScale,\n                parallaxScrollingScale,\n                parallaxAdjacentItemScale,\n            ],\n            Extrapolate.CLAMP\n        );\n\n        return {\n            transform: [\n                vertical\n                    ? {\n                          translateY: translate,\n                      }\n                    : {\n                          translateX: translate,\n                      },\n                {\n                    scale,\n                },\n            ],\n            zIndex,\n        };\n    }, [loop, vertical, parallaxScrollingOffset]);\n\n    const updateView = React.useCallback(\n        (negativeRange: number[], positiveRange: number[]) => {\n            setShouldUpdate(\n                (index >= negativeRange[0] && index <= negativeRange[1]) ||\n                    (index >= positiveRange[0] && index <= positiveRange[1])\n            );\n        },\n        [index]\n    );\n\n    useAnimatedReaction(\n        () => visibleRanges.value,\n        () => {\n            runOnJS(updateView)(\n                visibleRanges.value.negativeRange,\n                visibleRanges.value.positiveRange\n            );\n        },\n        [visibleRanges.value]\n    );\n\n    return (\n        <Animated.View\n            style={[\n                {\n                    width: width || '100%',\n                    height: height || '100%',\n                    position: 'absolute',\n                },\n                offsetXStyle,\n            ]}\n        >\n            <LazyView shouldUpdate={shouldUpdate}>{children}</LazyView>\n        </Animated.View>\n    );\n};\n"]}