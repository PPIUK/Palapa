{"version":3,"sources":["useOffsetX.ts"],"names":["useOffsetX","opts","visibleRanges","handlerOffsetX","index","size","loop","data","type","viewCount","Math","round","length","ITEM_LENGTH","VALID_LENGTH","TOTAL_WIDTH","HALF_WIDTH","positiveCount","startPos","MAX","MIN","x","value","negativeRange","positiveRange","Number","MAX_SAFE_INTEGER","inputRange","MIN_VALUE","outputRange","Extrapolate","CLAMP","interpolate"],"mappings":"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","sourcesContent":["import Animated, {\n    Extrapolate,\n    interpolate,\n    useDerivedValue,\n} from 'react-native-reanimated';\nimport type { IVisibleRanges } from './useVisibleRanges';\n\nexport interface IOpts {\n    index: number;\n    size: number;\n    handlerOffsetX: Animated.SharedValue<number>;\n    data: unknown[];\n    type?: 'positive' | 'negative';\n    viewCount?: number;\n    loop?: boolean;\n}\n\nexport const useOffsetX = (opts: IOpts, visibleRanges: IVisibleRanges) => {\n    const {\n        handlerOffsetX,\n        index,\n        size,\n        loop,\n        data,\n        type = 'positive',\n        viewCount = Math.round((data.length - 1) / 2),\n    } = opts;\n\n    const ITEM_LENGTH = data.length;\n    const VALID_LENGTH = ITEM_LENGTH - 1;\n    const TOTAL_WIDTH = size * ITEM_LENGTH;\n    const HALF_WIDTH = 0.5 * size;\n\n    const positiveCount =\n        type === 'positive' ? viewCount : VALID_LENGTH - viewCount;\n\n    let startPos = size * index;\n    if (index > positiveCount) {\n        startPos = (index - ITEM_LENGTH) * size;\n    }\n\n    const MAX = positiveCount * size;\n    const MIN = -((VALID_LENGTH - positiveCount) * size);\n\n    const x = useDerivedValue(() => {\n        const { negativeRange, positiveRange } = visibleRanges.value;\n        if (\n            (index < negativeRange[0] || index > negativeRange[1]) &&\n            (index < positiveRange[0] || index > positiveRange[1])\n        ) {\n            return Number.MAX_SAFE_INTEGER;\n        }\n\n        if (loop) {\n            const inputRange = [\n                -TOTAL_WIDTH,\n                MIN - HALF_WIDTH - startPos - Number.MIN_VALUE,\n                MIN - HALF_WIDTH - startPos,\n                0,\n                MAX + HALF_WIDTH - startPos,\n                MAX + HALF_WIDTH - startPos + Number.MIN_VALUE,\n                TOTAL_WIDTH,\n            ];\n\n            const outputRange = [\n                startPos,\n                MAX + HALF_WIDTH - Number.MIN_VALUE,\n                MIN - HALF_WIDTH,\n                startPos,\n                MAX + HALF_WIDTH,\n                MIN - HALF_WIDTH + Number.MIN_VALUE,\n                startPos,\n            ];\n\n            return interpolate(\n                handlerOffsetX.value,\n                inputRange,\n                outputRange,\n                Extrapolate.CLAMP\n            );\n        }\n\n        return handlerOffsetX.value + size * index;\n    }, [loop, data, viewCount, type, size, visibleRanges]);\n\n    return x;\n};\n"]}