import React from 'react';
import { Easing } from '../constants';
import { runOnJS, useSharedValue } from 'react-native-reanimated';
import { dealWithAnimation } from '@/utils/dealWithAnimation';
export function useCarouselController(options) {
  const {
    size,
    loop,
    handlerOffsetX,
    withAnimation,
    disable = false,
    originalLength,
    length,
    onChange,
    duration,
    defaultIndex = 0
  } = options;
  const index = useSharedValue(defaultIndex); // The Index displayed to the user

  const sharedIndex = React.useRef(defaultIndex);
  const sharedPreIndex = React.useRef(defaultIndex);
  const currentFixedPage = React.useCallback(() => {
    if (loop) {
      return -Math.round(handlerOffsetX.value / size);
    }

    const fixed = handlerOffsetX.value / size % length;
    return Math.round(handlerOffsetX.value <= 0 ? Math.abs(fixed) : Math.abs(fixed > 0 ? length - fixed : 0));
  }, [handlerOffsetX, length, size, loop]);
  const convertToSharedIndex = React.useCallback(i => {
    if (loop) {
      switch (originalLength) {
        case 1:
          return 0;

        case 2:
          return i % 2;
      }
    }

    return i;
  }, [originalLength, loop]);
  const computedIndex = React.useCallback(() => {
    sharedPreIndex.current = sharedIndex.current;
    const toInt = handlerOffsetX.value / size % length;
    const i = handlerOffsetX.value <= 0 ? Math.abs(toInt) : Math.abs(toInt > 0 ? length - toInt : 0);
    index.value = i;

    const _sharedIndex = convertToSharedIndex(i);

    sharedIndex.current = _sharedIndex;
    onChange(_sharedIndex);
  }, [length, handlerOffsetX, sharedPreIndex, index, size, sharedIndex, convertToSharedIndex, onChange]);
  const getCurrentIndex = React.useCallback(() => {
    return index.value;
  }, [index]);
  const canSliding = React.useCallback(() => {
    return !disable;
  }, [disable]);
  const onScrollEnd = React.useCallback(() => {
    var _options$onScrollEnd;

    (_options$onScrollEnd = options.onScrollEnd) === null || _options$onScrollEnd === void 0 ? void 0 : _options$onScrollEnd.call(options);
  }, [options]);
  const onScrollBegin = React.useCallback(() => {
    var _options$onScrollBegi;

    (_options$onScrollBegi = options.onScrollBegin) === null || _options$onScrollBegi === void 0 ? void 0 : _options$onScrollBegi.call(options);
  }, [options]);
  const scrollWithTiming = React.useCallback((toValue, onFinished) => {
    'worklet';

    const callback = isFinished => {
      'worklet';

      if (isFinished) {
        runOnJS(onScrollEnd)();
        onFinished && runOnJS(onFinished)();
      }
    };

    const defaultWithAnimation = {
      type: 'timing',
      config: {
        duration,
        easing: Easing.easeOutQuart
      }
    };
    return dealWithAnimation(withAnimation !== null && withAnimation !== void 0 ? withAnimation : defaultWithAnimation)(toValue, callback);
  }, [duration, withAnimation, onScrollEnd]);
  const next = React.useCallback(function () {
    'worklet';

    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      count = 1,
      animated = true,
      onFinished
    } = opts;
    if (!canSliding() || !loop && index.value >= length - 1) return;
    onScrollBegin === null || onScrollBegin === void 0 ? void 0 : onScrollBegin();
    const nextPage = currentFixedPage() + count;
    index.value = nextPage;

    if (animated) {
      handlerOffsetX.value = scrollWithTiming(-nextPage * size, onFinished);
    } else {
      handlerOffsetX.value = -nextPage * size;
      onFinished === null || onFinished === void 0 ? void 0 : onFinished();
    }
  }, [canSliding, loop, index, length, onScrollBegin, handlerOffsetX, size, scrollWithTiming, currentFixedPage]);
  const prev = React.useCallback(function () {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      count = 1,
      animated = true,
      onFinished
    } = opts;
    if (!canSliding() || !loop && index.value <= 0) return;
    onScrollBegin === null || onScrollBegin === void 0 ? void 0 : onScrollBegin();
    const prevPage = currentFixedPage() - count;
    index.value = prevPage;

    if (animated) {
      handlerOffsetX.value = scrollWithTiming(-prevPage * size, onFinished);
    } else {
      handlerOffsetX.value = -prevPage * size;
      onFinished === null || onFinished === void 0 ? void 0 : onFinished();
    }
  }, [canSliding, loop, index, onScrollBegin, handlerOffsetX, size, scrollWithTiming, currentFixedPage]);
  const to = React.useCallback(function (idx) {
    let animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (idx === index.value) return;
    if (!canSliding()) return;
    onScrollBegin === null || onScrollBegin === void 0 ? void 0 : onScrollBegin();
    const offset = handlerOffsetX.value + (index.value - idx) * size;

    if (animated) {
      index.value = idx;
      handlerOffsetX.value = scrollWithTiming(offset);
    } else {
      handlerOffsetX.value = offset;
      index.value = idx;
      runOnJS(onScrollEnd)();
    }
  }, [index, canSliding, onScrollBegin, handlerOffsetX, size, scrollWithTiming, onScrollEnd]);
  const scrollTo = React.useCallback(function () {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      count,
      animated = false,
      onFinished
    } = opts;

    if (!count) {
      return;
    }

    const n = Math.round(count);

    if (n < 0) {
      prev({
        count: Math.abs(n),
        animated,
        onFinished
      });
    } else {
      next({
        count: n,
        animated,
        onFinished
      });
    }
  }, [prev, next]);
  return {
    next,
    prev,
    to,
    scrollTo,
    index,
    length,
    sharedIndex,
    sharedPreIndex,
    computedIndex,
    getCurrentIndex
  };
}
//# sourceMappingURL=useCarouselController.js.map