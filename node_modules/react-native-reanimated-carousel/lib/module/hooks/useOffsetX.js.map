{"version":3,"sources":["useOffsetX.ts"],"names":["Extrapolate","interpolate","useDerivedValue","useOffsetX","opts","visibleRanges","handlerOffsetX","index","size","loop","data","type","viewCount","Math","round","length","ITEM_LENGTH","VALID_LENGTH","TOTAL_WIDTH","HALF_WIDTH","positiveCount","startPos","MAX","MIN","x","negativeRange","positiveRange","value","Number","MAX_SAFE_INTEGER","inputRange","MIN_VALUE","outputRange","CLAMP"],"mappings":"AAAA,SACIA,WADJ,EAEIC,WAFJ,EAGIC,eAHJ,QAIO,yBAJP;AAiBA,OAAO,MAAMC,UAAU,GAAG,CAACC,IAAD,EAAcC,aAAd,KAAgD;AACtE,QAAM;AACFC,IAAAA,cADE;AAEFC,IAAAA,KAFE;AAGFC,IAAAA,IAHE;AAIFC,IAAAA,IAJE;AAKFC,IAAAA,IALE;AAMFC,IAAAA,IAAI,GAAG,UANL;AAOFC,IAAAA,SAAS,GAAGC,IAAI,CAACC,KAAL,CAAW,CAACJ,IAAI,CAACK,MAAL,GAAc,CAAf,IAAoB,CAA/B;AAPV,MAQFX,IARJ;AAUA,QAAMY,WAAW,GAAGN,IAAI,CAACK,MAAzB;AACA,QAAME,YAAY,GAAGD,WAAW,GAAG,CAAnC;AACA,QAAME,WAAW,GAAGV,IAAI,GAAGQ,WAA3B;AACA,QAAMG,UAAU,GAAG,MAAMX,IAAzB;AAEA,QAAMY,aAAa,GACfT,IAAI,KAAK,UAAT,GAAsBC,SAAtB,GAAkCK,YAAY,GAAGL,SADrD;AAGA,MAAIS,QAAQ,GAAGb,IAAI,GAAGD,KAAtB;;AACA,MAAIA,KAAK,GAAGa,aAAZ,EAA2B;AACvBC,IAAAA,QAAQ,GAAG,CAACd,KAAK,GAAGS,WAAT,IAAwBR,IAAnC;AACH;;AAED,QAAMc,GAAG,GAAGF,aAAa,GAAGZ,IAA5B;AACA,QAAMe,GAAG,GAAG,EAAE,CAACN,YAAY,GAAGG,aAAhB,IAAiCZ,IAAnC,CAAZ;AAEA,QAAMgB,CAAC,GAAGtB,eAAe,CAAC,MAAM;AAC5B,UAAM;AAAEuB,MAAAA,aAAF;AAAiBC,MAAAA;AAAjB,QAAmCrB,aAAa,CAACsB,KAAvD;;AACA,QACI,CAACpB,KAAK,GAAGkB,aAAa,CAAC,CAAD,CAArB,IAA4BlB,KAAK,GAAGkB,aAAa,CAAC,CAAD,CAAlD,MACClB,KAAK,GAAGmB,aAAa,CAAC,CAAD,CAArB,IAA4BnB,KAAK,GAAGmB,aAAa,CAAC,CAAD,CADlD,CADJ,EAGE;AACE,aAAOE,MAAM,CAACC,gBAAd;AACH;;AAED,QAAIpB,IAAJ,EAAU;AACN,YAAMqB,UAAU,GAAG,CACf,CAACZ,WADc,EAEfK,GAAG,GAAGJ,UAAN,GAAmBE,QAAnB,GAA8BO,MAAM,CAACG,SAFtB,EAGfR,GAAG,GAAGJ,UAAN,GAAmBE,QAHJ,EAIf,CAJe,EAKfC,GAAG,GAAGH,UAAN,GAAmBE,QALJ,EAMfC,GAAG,GAAGH,UAAN,GAAmBE,QAAnB,GAA8BO,MAAM,CAACG,SANtB,EAOfb,WAPe,CAAnB;AAUA,YAAMc,WAAW,GAAG,CAChBX,QADgB,EAEhBC,GAAG,GAAGH,UAAN,GAAmBS,MAAM,CAACG,SAFV,EAGhBR,GAAG,GAAGJ,UAHU,EAIhBE,QAJgB,EAKhBC,GAAG,GAAGH,UALU,EAMhBI,GAAG,GAAGJ,UAAN,GAAmBS,MAAM,CAACG,SANV,EAOhBV,QAPgB,CAApB;AAUA,aAAOpB,WAAW,CACdK,cAAc,CAACqB,KADD,EAEdG,UAFc,EAGdE,WAHc,EAIdhC,WAAW,CAACiC,KAJE,CAAlB;AAMH;;AAED,WAAO3B,cAAc,CAACqB,KAAf,GAAuBnB,IAAI,GAAGD,KAArC;AACH,GAvCwB,EAuCtB,CAACE,IAAD,EAAOC,IAAP,EAAaE,SAAb,EAAwBD,IAAxB,EAA8BH,IAA9B,EAAoCH,aAApC,CAvCsB,CAAzB;AAyCA,SAAOmB,CAAP;AACH,CArEM","sourcesContent":["import Animated, {\n    Extrapolate,\n    interpolate,\n    useDerivedValue,\n} from 'react-native-reanimated';\nimport type { IVisibleRanges } from './useVisibleRanges';\n\nexport interface IOpts {\n    index: number;\n    size: number;\n    handlerOffsetX: Animated.SharedValue<number>;\n    data: unknown[];\n    type?: 'positive' | 'negative';\n    viewCount?: number;\n    loop?: boolean;\n}\n\nexport const useOffsetX = (opts: IOpts, visibleRanges: IVisibleRanges) => {\n    const {\n        handlerOffsetX,\n        index,\n        size,\n        loop,\n        data,\n        type = 'positive',\n        viewCount = Math.round((data.length - 1) / 2),\n    } = opts;\n\n    const ITEM_LENGTH = data.length;\n    const VALID_LENGTH = ITEM_LENGTH - 1;\n    const TOTAL_WIDTH = size * ITEM_LENGTH;\n    const HALF_WIDTH = 0.5 * size;\n\n    const positiveCount =\n        type === 'positive' ? viewCount : VALID_LENGTH - viewCount;\n\n    let startPos = size * index;\n    if (index > positiveCount) {\n        startPos = (index - ITEM_LENGTH) * size;\n    }\n\n    const MAX = positiveCount * size;\n    const MIN = -((VALID_LENGTH - positiveCount) * size);\n\n    const x = useDerivedValue(() => {\n        const { negativeRange, positiveRange } = visibleRanges.value;\n        if (\n            (index < negativeRange[0] || index > negativeRange[1]) &&\n            (index < positiveRange[0] || index > positiveRange[1])\n        ) {\n            return Number.MAX_SAFE_INTEGER;\n        }\n\n        if (loop) {\n            const inputRange = [\n                -TOTAL_WIDTH,\n                MIN - HALF_WIDTH - startPos - Number.MIN_VALUE,\n                MIN - HALF_WIDTH - startPos,\n                0,\n                MAX + HALF_WIDTH - startPos,\n                MAX + HALF_WIDTH - startPos + Number.MIN_VALUE,\n                TOTAL_WIDTH,\n            ];\n\n            const outputRange = [\n                startPos,\n                MAX + HALF_WIDTH - Number.MIN_VALUE,\n                MIN - HALF_WIDTH,\n                startPos,\n                MAX + HALF_WIDTH,\n                MIN - HALF_WIDTH + Number.MIN_VALUE,\n                startPos,\n            ];\n\n            return interpolate(\n                handlerOffsetX.value,\n                inputRange,\n                outputRange,\n                Extrapolate.CLAMP\n            );\n        }\n\n        return handlerOffsetX.value + size * index;\n    }, [loop, data, viewCount, type, size, visibleRanges]);\n\n    return x;\n};\n"]}