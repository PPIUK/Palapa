{"version":3,"sources":["TPhrasingCtor.ts"],"names":["isChildEmpty","c","isEmpty","TPhrasingCtor","TPhrasing","init","initialize","prototype","TNodeCtor","matchContentModel","contentModel","HTMLContentModel","textual","mixed","tagName","children","every","collapseChildren","previous","forEach","childK","k","j","collapse","isCollapsibleLeft","isCollapsibleRight","trimLeft","trimRight"],"mappings":";;;;;;;AAAA;;AACA;;;;AAKA,SAASA,YAAT,CAAsBC,CAAtB,EAAoC;AAClC,SAAOA,CAAC,CAACC,OAAF,EAAP;AACD;;AAED,MAAMC,aAAa,GAAG,SAASC,SAAT,CAEpBC,IAFoB,EAGpB;AACA,OAAKC,UAAL,CAAgBD,IAAhB;AACD,CALD,C,CAOA;;;;AACAF,aAAa,CAACI,SAAd,GAA0B,IAAIC,kBAAJ,CAAc,UAAd,EAA0B,WAA1B,CAA1B;;AAEAL,aAAa,CAACI,SAAd,CAAwBE,iBAAxB,GAA4C,SAASA,iBAAT,CAC1CC,YAD0C,EAE1C;AACA,SACEA,YAAY,KAAKC,0BAAiBC,OAAlC,IACAF,YAAY,KAAKC,0BAAiBE,KAFpC;AAID,CAPD;;AASAV,aAAa,CAACI,SAAd,CAAwBL,OAAxB,GAAkC,SAASA,OAAT,GAAmB;AACnD;AACA,SAAO,KAAKY,OAAL,KAAiB,IAAjB,IAAyB,KAAKC,QAAL,CAAcC,KAAd,CAAoBhB,YAApB,CAAhC;AACD,CAHD;;AAKAG,aAAa,CAACI,SAAd,CAAwBU,gBAAxB,GAA2C,SAASA,gBAAT,GAA4B;AACrE,MAAIC,QAA0B,GAAG,IAAjC;AACA,OAAKH,QAAL,CAAcI,OAAd,CAAsB,CAACC,MAAD,EAASC,CAAT,KAAe;AACnC,UAAMC,CAAC,GAAGD,CAAC,GAAG,CAAd;AACAD,IAAAA,MAAM,CAACG,QAAP;;AACA,QACED,CAAC,GAAG,CAAC,CAAL,IACAF,MAAM,CAACI,iBAAP,EADA,IAECN,QAAD,CAAwBO,kBAAxB,EAHF,EAIE;AACA;AACA;AACAL,MAAAA,MAAM,CAACM,QAAP;AACD;;AACDR,IAAAA,QAAQ,GAAGE,MAAX;AACD,GAbD;AAcA,OAAKM,QAAL;AACA,OAAKC,SAAL;AACA,SAAO,IAAP;AACD,CAnBD;;eAqBexB,a","sourcesContent":["import HTMLContentModel from '../model/HTMLContentModel';\nimport TNodeCtor, { GenericTNodeCtor, Mutable } from './TNodeCtor';\nimport { TNodeImpl, TNodeInit } from './tree-types';\n\nexport interface TPhrasingImpl extends TNodeImpl {}\n\nfunction isChildEmpty(c: TNodeImpl) {\n  return c.isEmpty();\n}\n\nconst TPhrasingCtor = function TPhrasing(\n  this: Mutable<TNodeImpl>,\n  init: TNodeInit\n) {\n  this.initialize(init);\n} as Function as GenericTNodeCtor<TNodeInit, TPhrasingImpl>;\n\n//@ts-ignore\nTPhrasingCtor.prototype = new TNodeCtor('phrasing', 'TPhrasing');\n\nTPhrasingCtor.prototype.matchContentModel = function matchContentModel(\n  contentModel\n) {\n  return (\n    contentModel === HTMLContentModel.textual ||\n    contentModel === HTMLContentModel.mixed\n  );\n};\n\nTPhrasingCtor.prototype.isEmpty = function isEmpty() {\n  // Only anonymous phrasing nodes with every children empty can be considered \"empty\"\n  return this.tagName === null && this.children.every(isChildEmpty);\n};\n\nTPhrasingCtor.prototype.collapseChildren = function collapseChildren() {\n  let previous: TNodeImpl | null = null;\n  this.children.forEach((childK, k) => {\n    const j = k - 1;\n    childK.collapse();\n    if (\n      j > -1 &&\n      childK.isCollapsibleLeft() &&\n      (previous as TNodeImpl).isCollapsibleRight()\n    ) {\n      // We must trim left from current to support trimming\n      // after <br> and <wbr> tags.\n      childK.trimLeft();\n    }\n    previous = childK;\n  });\n  this.trimLeft();\n  this.trimRight();\n  return null;\n};\n\nexport default TPhrasingCtor;\n\nexport { TPhrasingCtor };\n"]}